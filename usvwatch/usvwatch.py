#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# USVWatch (UGREEN NAS) - UPS/USV Status Mail Notifier via NUT
#
# Copyright (c) 2026 Roman Glos
# All rights reserved.
#
# Requirements:
# - Python 3 (standard library only)
# - NUT server reachable (UGOS Pro UPS settings), default port 3493
#
# Examples:
#   python3 usvwatch.py --print-status
#   python3 usvwatch.py --test-mail
#   python3 usvwatch.py --list-commands
#   python3 usvwatch.py --run-cmd beeper.mute
#   python3 usvwatch.py --run-cmd beeper.mute --run-cmd-mail
#   python3 usvwatch.py                # run once (cron), loads ./usvwatch.env by default
#
from __future__ import annotations

import argparse
import datetime as _dt
import json
import os
import re
import shlex
import socket
import ssl
import sys
from email.message import EmailMessage
from pathlib import Path
from typing import Dict, List, Optional, Tuple


# ---------------------------
# i18n strings
# ---------------------------
I18N = {
    "de": {
        "product": "USVWatch",
        "test_subject": "USV: Test-E-Mail",
        "selftest_subject": "USV: Selbsttest ausgelöst",
        "on_battery_subject": "USV: Stromausfall, Batteriebetrieb",
        "back_online_subject": "USV: Netzstrom wieder da",
        "low_batt_subject": "USV: Batterie kritisch",
        "charge_low_subject": "USV: Akkuladung unter Schwelle",
        "runtime_low_subject": "USV: Laufzeit unter Schwelle",
        "unreachable_subject": "USV: Status nicht erreichbar",
        "recovered_subject": "USV: Status wieder erreichbar",
        "daily_subject": "USV: Tagesreport",
        "title": "USV-Statusbericht",
        "timestamp": "Zeitstempel",
        "host": "Host",
        "ups": "USV",
        "ups_desc": "Beschreibung",
        "summary": "Kurzstatus",
        "all_vars": "Alle USV-Werte",
        "status": "Netzstatus",
        "battery_charge": "Akkuladung",
        "battery_runtime": "Verbleibende Laufzeit",
        "input_voltage": "Eingangsspannung",
        "output_voltage": "Ausgangsspannung",
        "load": "Auslastung",
        "temperature": "Temperatur",
        "manufacturer": "Hersteller",
        "model": "Modell",
        "serial": "Seriennummer",
        "firmware": "Firmware",
        "unreachable_hint": "Der NUT-Dienst ist nicht erreichbar. Host/Port, Firewall oder Dienststatus prüfen.",
        "footer": "Automatisch erzeugt von USVWatch.",
        "event_test": "Test",
        "event_selftest": "Selbsttest ausgelöst",
        "event_on_battery": "Stromausfall (Batteriebetrieb)",
        "event_back_online": "Netzstrom wieder da",
        "event_low_battery": "Batterie kritisch",
        "event_charge_low": "Akkuladung unter Schwelle",
        "event_runtime_low": "Laufzeit unter Schwelle",
        "event_unreachable": "Status nicht erreichbar",
        "event_recovered": "Status wieder erreichbar",
        "event_daily": "Tagesreport",
        "status_legend": "Status-Codes (Erklärung)",
        "status_unknown": "Unbekannt",
        "cmd_list_title": "Verfügbare Kommandos",
        "cmd_run_ok": "Kommando erfolgreich ausgeführt",
        "cmd_run_err": "Kommando fehlgeschlagen",
        "cmd_run_label": "Ausgeführtes Kommando",
        "cmd_run_result": "Ergebnis",
    },
    "en": {
        "product": "USVWatch",
        "test_subject": "UPS: Test email",
        "selftest_subject": "UPS: Self-test triggered",
        "on_battery_subject": "UPS: Power outage, on battery",
        "back_online_subject": "UPS: Mains power restored",
        "low_batt_subject": "UPS: Battery critical",
        "charge_low_subject": "UPS: Charge below threshold",
        "runtime_low_subject": "UPS: Runtime below threshold",
        "unreachable_subject": "UPS: Status not reachable",
        "recovered_subject": "UPS: Status reachable again",
        "daily_subject": "UPS: Daily report",
        "title": "UPS status report",
        "timestamp": "Timestamp",
        "host": "Host",
        "ups": "UPS",
        "ups_desc": "Description",
        "summary": "Summary",
        "all_vars": "All UPS values",
        "status": "Status",
        "battery_charge": "Battery charge",
        "battery_runtime": "Estimated runtime",
        "input_voltage": "Input voltage",
        "output_voltage": "Output voltage",
        "load": "Load",
        "temperature": "Temperature",
        "manufacturer": "Manufacturer",
        "model": "Model",
        "serial": "Serial number",
        "firmware": "Firmware",
        "unreachable_hint": "The NUT service is not reachable. Check host/port, firewall, and service status.",
        "footer": "Auto generated by USVWatch.",
        "event_test": "Test",
        "event_selftest": "Self-test triggered",
        "event_on_battery": "Power outage (on battery)",
        "event_back_online": "Mains power restored",
        "event_low_battery": "Battery critical",
        "event_charge_low": "Charge below threshold",
        "event_runtime_low": "Runtime below threshold",
        "event_unreachable": "Status not reachable",
        "event_recovered": "Status reachable again",
        "event_daily": "Daily report",
        "status_legend": "Status codes (legend)",
        "status_unknown": "Unknown",
        "cmd_list_title": "Available commands",
        "cmd_run_ok": "Command executed successfully",
        "cmd_run_err": "Command failed",
        "cmd_run_label": "Executed command",
        "cmd_run_result": "Result",
    },
}


# ---------------------------
# Status flag explanations
# ---------------------------
STATUS_FLAG_MAP = {
    "OL": {"de": "Netzbetrieb", "en": "On line"},
    "OB": {"de": "Batteriebetrieb", "en": "On battery"},
    "LB": {"de": "Batterie schwach", "en": "Low battery"},
    "RB": {"de": "Batterie wird wieder geladen", "en": "Battery is recharging"},
    "CHRG": {"de": "Batterie lädt", "en": "Charging"},
    "DISCHRG": {"de": "Batterie entlädt", "en": "Discharging"},
    "BYPASS": {"de": "Bypass aktiv", "en": "Bypass active"},
    "OVER": {"de": "Überlast", "en": "Overload"},
    "TRIM": {"de": "Eingangsspannung wird reduziert", "en": "Trimming input voltage"},
    "BOOST": {"de": "Eingangsspannung wird angehoben", "en": "Boosting input voltage"},
    "FSD": {"de": "Shutdown läuft", "en": "Forced shutdown in progress"},
    "OFF": {"de": "Aus", "en": "Off"},
    "CAL": {"de": "Kalibrierung", "en": "Calibration"},
    "ALARM": {"de": "Alarm", "en": "Alarm"},
    "TEST": {"de": "Selbsttest", "en": "Self test"},
}


def explain_ups_status(raw_status: str, lang: str) -> Tuple[str, List[str]]:
    raw = (raw_status or "").strip()
    flags = [f for f in raw.split() if f]
    if not flags:
        return (I18N.get(lang, I18N["de"])["status_unknown"], [])
    parts = []
    for f in flags:
        txt = STATUS_FLAG_MAP.get(f, {}).get(lang)
        parts.append(f"{txt} ({f})" if txt else f"{f}")
    return (", ".join(parts), flags)


# ---------------------------
# Helpers
# ---------------------------
def _now_local() -> _dt.datetime:
    return _dt.datetime.now()


def _dt_to_iso(dt: Optional[_dt.datetime]) -> Optional[str]:
    return dt.isoformat(timespec="seconds") if dt else None


def _iso_to_dt(s: Optional[str]) -> Optional[_dt.datetime]:
    if not s:
        return None
    try:
        return _dt.datetime.fromisoformat(s)
    except Exception:
        return None


def _safe_int(v: Optional[str]) -> Optional[int]:
    if v is None:
        return None
    try:
        return int(float(str(v).strip()))
    except Exception:
        return None


def _safe_float(v: Optional[str]) -> Optional[float]:
    if v is None:
        return None
    try:
        return float(str(v).strip())
    except Exception:
        return None


def _fmt_seconds(seconds: Optional[int]) -> str:
    if seconds is None or seconds < 0:
        return "-"
    m, _s = divmod(seconds, 60)
    h, m = divmod(m, 60)
    if h > 0:
        return f"{h} h {m} min"
    return f"{m} min"


def _truncate_subject(s: str, max_len: int = 64) -> str:
    s = s.strip()
    return s if len(s) <= max_len else (s[: max_len - 1].rstrip() + "…")


def load_env_file(path: Path) -> None:
    """
    Lightweight env loader (no external deps).
    Supports:
      KEY=VALUE
      export KEY="VALUE"
    Ignores comments and blank lines.

    Note:
      We do NOT overwrite existing environment variables on purpose.
      Use USVWATCH_LANG (not LANG) to control language reliably.
    """
    if not path.exists():
        return
    for raw in path.read_text(encoding="utf-8", errors="replace").splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        if line.lower().startswith("export "):
            line = line[7:].strip()
        if "=" not in line:
            continue
        key, val = line.split("=", 1)
        key = key.strip()
        val = val.strip()
        if not key:
            continue
        if (val.startswith('"') and val.endswith('"')) or (val.startswith("'") and val.endswith("'")):
            val = val[1:-1]
        if key not in os.environ:
            os.environ[key] = val


def env_bool(name: str, default: bool = False) -> bool:
    v = os.environ.get(name)
    if v is None:
        return default
    return str(v).strip().lower() in {"1", "true", "yes", "y", "on"}


def env_str(name: str, default: str = "") -> str:
    v = os.environ.get(name)
    return default if v is None else str(v)


def env_int(name: str, default: int) -> int:
    v = os.environ.get(name)
    if v is None:
        return default
    try:
        return int(str(v).strip())
    except Exception:
        return default


def env_float(name: str, default: float) -> float:
    v = os.environ.get(name)
    if v is None:
        return default
    try:
        return float(str(v).strip())
    except Exception:
        return default


# ---------------------------
# NUT client (TCP protocol)
# ---------------------------
class NutClientError(RuntimeError):
    pass


class NutClient:
    def __init__(self, host: str, port: int, timeout: float = 5.0):
        self.host = host
        self.port = port
        self.timeout = timeout
        self._sock: Optional[socket.socket] = None

    def __enter__(self) -> "NutClient":
        self._sock = socket.create_connection((self.host, self.port), timeout=self.timeout)
        self._sock.settimeout(self.timeout)
        return self

    def __exit__(self, exc_type, exc, tb) -> None:
        try:
            if self._sock:
                self._sock.close()
        finally:
            self._sock = None

    def _send(self, cmd: str) -> None:
        if not self._sock:
            raise NutClientError("Not connected")
        self._sock.sendall((cmd.strip() + "\n").encode("utf-8", errors="ignore"))

    def _recv_line(self) -> str:
        if not self._sock:
            raise NutClientError("Not connected")
        buf = b""
        while True:
            ch = self._sock.recv(1)
            if not ch:
                raise NutClientError("Connection closed")
            if ch == b"\n":
                break
            buf += ch
            if len(buf) > 65536:
                raise NutClientError("Line too long")
        return buf.decode("utf-8", errors="replace").rstrip("\r")

    def _read_list_until(self, end_marker: str) -> List[str]:
        lines: List[str] = []
        for _ in range(20000):
            line = self._recv_line()
            if line == end_marker:
                return lines
            if line.startswith("ERR "):
                raise NutClientError(line)
            lines.append(line)
        raise NutClientError("List read exceeded limit")

    def login_if_needed(self, username: str, password: str) -> None:
        """Authenticate to upsd if username is provided.

        Compatibility:
          - Standard NUT protocol: USERNAME + PASSWORD
          - Some builds may use:    LOGIN <user> <pass>
        """
        if not username:
            return

        # 1) Try standard USERNAME/PASSWORD flow
        self._send(f"USERNAME {username}")
        r1 = self._recv_line()
        if r1.startswith("ERR "):
            # Fallback: some servers use LOGIN <user> <pass>
            if "UNKNOWN-COMMAND" in r1:
                self._send(f"LOGIN {username} {password}")
                r_login = self._recv_line()
                if r_login.startswith("ERR "):
                    raise NutClientError(r_login)
                return
            raise NutClientError(r1)

        self._send(f"PASSWORD {password}")
        r2 = self._recv_line()
        if r2.startswith("ERR "):
            raise NutClientError(r2)

        # Do NOT send a bare LOGIN. Some servers treat that as invalid-argument.
        return

    def list_ups(self) -> List[Tuple[str, str]]:
        self._send("LIST UPS")
        lines = self._read_list_until("END LIST UPS")
        res: List[Tuple[str, str]] = []
        for line in lines:
            if not line.startswith("UPS "):
                continue
            try:
                parts = shlex.split(line)
                name = parts[1]
                desc = parts[2] if len(parts) >= 3 else ""
                res.append((name, desc))
            except Exception:
                continue
        return res

    def list_vars(self, ups: str) -> Dict[str, str]:
        self._send(f"LIST VAR {ups}")
        lines = self._read_list_until(f"END LIST VAR {ups}")
        vars_: Dict[str, str] = {}
        for line in lines:
            if not line.startswith("VAR "):
                continue
            try:
                parts = shlex.split(line)
                if len(parts) < 4:
                    continue
                varname = parts[2]
                value = parts[3]
                vars_[varname] = value
            except Exception:
                continue
        return vars_

    def list_cmds(self, ups: str) -> List[str]:
        self._send(f"LIST CMD {ups}")
        lines = self._read_list_until(f"END LIST CMD {ups}")
        cmds: List[str] = []
        for line in lines:
            if not line.startswith("CMD "):
                continue
            try:
                parts = shlex.split(line)
                # CMD <ups> <cmd>
                if len(parts) >= 3:
                    cmds.append(parts[2])
            except Exception:
                continue
        return sorted(set(cmds), key=lambda s: s.lower())

    def instcmd(self, ups: str, cmd: str) -> str:
        # NUT: INSTCMD <ups> <cmd>
        self._send(f"INSTCMD {ups} {cmd}")
        r = self._recv_line()
        if r.startswith("ERR "):
            raise NutClientError(r)
        return r


# ---------------------------
# Mail
# ---------------------------
def send_mail(
    *,
    smtp_host: str,
    smtp_port: int,
    smtp_user: str,
    smtp_pass: str,
    smtp_from: str,
    smtp_to: List[str],
    smtp_cc: List[str],
    smtp_bcc: List[str],
    smtp_tls: str,
    smtp_timeout: int,
    tls_verify: bool,
    subject: str,
    html_body: str,
) -> None:
    import smtplib

    msg = EmailMessage()
    msg["Subject"] = _truncate_subject(subject, 64)
    msg["From"] = smtp_from
    msg["To"] = ", ".join(smtp_to)
    if smtp_cc:
        msg["Cc"] = ", ".join(smtp_cc)

    msg.set_content("This message contains HTML. Please use an HTML capable mail client.")
    msg.add_alternative(html_body, subtype="html")

    recipients = smtp_to + smtp_cc + smtp_bcc

    def mk_ctx() -> ssl.SSLContext:
        return ssl.create_default_context() if tls_verify else ssl._create_unverified_context()  # noqa: SLF001

    tls = smtp_tls.lower()
    if tls == "starttls":
        with smtplib.SMTP(smtp_host, smtp_port, timeout=smtp_timeout) as s:
            s.ehlo()
            s.starttls(context=mk_ctx())
            s.ehlo()
            if smtp_user:
                s.login(smtp_user, smtp_pass)
            s.send_message(msg, from_addr=smtp_from, to_addrs=recipients)
    elif tls == "ssl":
        with smtplib.SMTP_SSL(smtp_host, smtp_port, timeout=smtp_timeout, context=mk_ctx()) as s:
            s.ehlo()
            if smtp_user:
                s.login(smtp_user, smtp_pass)
            s.send_message(msg, from_addr=smtp_from, to_addrs=recipients)
    else:
        with smtplib.SMTP(smtp_host, smtp_port, timeout=smtp_timeout) as s:
            s.ehlo()
            if smtp_user:
                s.login(smtp_user, smtp_pass)
            s.send_message(msg, from_addr=smtp_from, to_addrs=recipients)


# ---------------------------
# HTML rendering
# ---------------------------
def _html_escape(s: str) -> str:
    return (
        s.replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
        .replace("'", "&#39;")
    )


def build_html(
    *,
    lang: str,
    event_label: str,
    now: _dt.datetime,
    host: str,
    ups_name: str,
    ups_desc: str,
    vars_: Dict[str, str],
    include_all_vars: bool,
    include_status_legend: bool,
    add_human_status_field: bool,
    extra_rows: Optional[List[Tuple[str, str]]] = None,
    all_vars_include_regex: str,
    all_vars_exclude_regex: str,
) -> str:
    t = I18N.get(lang, I18N["de"])

    def row(k: str, v: str, bg: str = "") -> str:
        style_bg = f"background:{bg};" if bg else ""
        return (
            "<tr>"
            f"<td style='padding:6px 10px;border:1px solid #ddd;white-space:nowrap;{style_bg}'>"
            f"<b>{_html_escape(k)}</b></td>"
            f"<td style='padding:6px 10px;border:1px solid #ddd;{style_bg}'>{_html_escape(v)}</td>"
            "</tr>"
        )

    ups_status_raw = vars_.get("ups.status", "-")
    status_human, flags = explain_ups_status(ups_status_raw, lang)

    bg_status = ""
    if "OB" in flags:
        bg_status = "#fff1f0"
    elif "LB" in flags or "OVER" in flags or "ALARM" in flags:
        bg_status = "#fff7e6"

    charge = vars_.get("battery.charge", "-")
    runtime_sec = _safe_int(vars_.get("battery.runtime"))
    runtime = _fmt_seconds(runtime_sec)

    input_v = vars_.get("input.voltage", "-")
    output_v = vars_.get("output.voltage", "-")
    load = vars_.get("ups.load", "-")
    temp = vars_.get("ups.temperature", vars_.get("temperature", "-"))

    mfr = vars_.get("device.mfr", vars_.get("ups.mfr", "-"))
    model = vars_.get("device.model", vars_.get("ups.model", "-"))
    serial = vars_.get("device.serial", vars_.get("ups.serial", "-"))
    fw = vars_.get("ups.firmware", vars_.get("device.firmware", "-"))

    status_value = status_human if status_human else ups_status_raw

    summary_rows = [
        row(t["status"], status_value, bg_status),
        row(t["battery_charge"], f"{charge} %" if re.fullmatch(r"\d+(\.\d+)?", str(charge)) else str(charge)),
        row(t["battery_runtime"], runtime),
        row(t["input_voltage"], f"{input_v} V" if input_v not in {"-", ""} else "-"),
        row(t["output_voltage"], f"{output_v} V" if output_v not in {"-", ""} else "-"),
        row(t["load"], f"{load} %" if load not in {"-", ""} else "-"),
        row(t["temperature"], f"{temp} °C" if temp not in {"-", ""} else "-"),
        row(t["manufacturer"], mfr),
        row(t["model"], model),
        row(t["serial"], serial),
        row(t["firmware"], fw),
    ]

    if extra_rows:
        for k, v in extra_rows:
            summary_rows.append(row(k, v))

    vars_for_table = dict(vars_)
    if add_human_status_field:
        vars_for_table["ups.status.human"] = status_human

    all_rows = ""
    if include_all_vars:
        inc_re = re.compile(all_vars_include_regex) if all_vars_include_regex else None
        exc_re = re.compile(all_vars_exclude_regex) if all_vars_exclude_regex else None

        items = []
        for k, v in vars_for_table.items():
            if inc_re and not inc_re.search(k):
                continue
            if exc_re and exc_re.search(k):
                continue
            items.append((k, v))
        items.sort(key=lambda kv: kv[0].lower())
        all_rows = "\n".join(row(k, v) for k, v in items)

    legend_html = ""
    if include_status_legend:
        order = ["OL", "OB", "LB", "RB", "CHRG", "DISCHRG", "BYPASS", "OVER", "TRIM", "BOOST", "FSD", "OFF", "CAL", "ALARM", "TEST"]
        legend_rows = []
        for code in order:
            txt = STATUS_FLAG_MAP.get(code, {}).get(lang)
            if txt:
                legend_rows.append(row(code, txt))
        legend_html = f"""
        <div style="font-size:15px; font-weight:700; margin:18px 0 8px;">{_html_escape(t["status_legend"])}</div>
        <table role="presentation" style="border-collapse:collapse; width:100%; margin-bottom:18px;">
          {''.join(legend_rows)}
        </table>
        """.strip()

    html = f"""
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{_html_escape(t["title"])}</title>
</head>
<body style="font-family:Segoe UI,Arial,sans-serif; background:#f6f7f8; padding:18px;">
  <div style="max-width:900px; margin:0 auto; background:#ffffff; border:1px solid #e5e5e5; border-radius:10px; overflow:hidden;">
    <div style="padding:16px 18px; background:#0b5cab; color:#ffffff;">
      <div style="font-size:18px; font-weight:700;">{_html_escape(t["title"])}</div>
      <div style="opacity:0.95; margin-top:4px;">{_html_escape(event_label)}</div>
    </div>

    <div style="padding:18px;">
      <table role="presentation" style="border-collapse:collapse; width:100%; margin-bottom:16px;">
        {row(t["timestamp"], now.strftime("%Y-%m-%d %H:%M:%S"))}
        {row(t["host"], host)}
        {row(t["ups"], ups_name)}
        {row(t["ups_desc"], ups_desc or "-")}
      </table>

      <div style="font-size:15px; font-weight:700; margin:10px 0 8px;">{_html_escape(t["summary"])}</div>
      <table role="presentation" style="border-collapse:collapse; width:100%; margin-bottom:18px;">
        {''.join(summary_rows)}
      </table>

      {legend_html}

      {"<div style='font-size:15px; font-weight:700; margin:10px 0 8px;'>" + _html_escape(t["all_vars"]) + "</div>" if include_all_vars else ""}
      {"<table role='presentation' style='border-collapse:collapse; width:100%;'>" + all_rows + "</table>" if include_all_vars else ""}

      <div style="margin-top:18px; color:#666; font-size:12px;">{_html_escape(t["footer"])}</div>
    </div>
  </div>
</body>
</html>
"""
    return html.strip()


# ---------------------------
# State
# ---------------------------
def load_state(path: Path) -> dict:
    if not path.exists():
        return {}
    try:
        return json.loads(path.read_text(encoding="utf-8", errors="replace"))
    except Exception:
        return {}


def save_state(path: Path, state: dict) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    tmp = path.with_suffix(".tmp")
    tmp.write_text(json.dumps(state, indent=2, ensure_ascii=False), encoding="utf-8")
    tmp.replace(path)


# ---------------------------
# Core logic
# ---------------------------
def pick_language() -> str:
    lang = env_str("USVWATCH_LANG", "").strip().lower()
    if not lang:
        lang = env_str("LANG", "de").strip().lower()
    return "en" if lang.startswith("en") else "de"


def _nut_connect_params() -> Tuple[str, int, float, str, str]:
    host = env_str("NUT_HOST", "127.0.0.1").strip()
    port = env_int("NUT_PORT", 3493)
    timeout = env_float("NUT_TIMEOUT", 5.0)
    username = env_str("NUT_USERNAME", "").strip()
    password = env_str("NUT_PASSWORD", "").strip()
    return host, port, timeout, username, password


def nut_select_ups() -> Tuple[str, str]:
    host, port, timeout, username, password = _nut_connect_params()
    ups_pref = env_str("NUT_UPS_NAME", "").strip()

    with NutClient(host, port, timeout=timeout) as c:
        c.login_if_needed(username, password)
        ups_list = c.list_ups()
        if not ups_list:
            raise NutClientError("No UPS found via NUT (LIST UPS empty).")

        ups_name, ups_desc = "", ""
        if ups_pref:
            for n, d in ups_list:
                if n == ups_pref:
                    ups_name, ups_desc = n, d
                    break
            if not ups_name:
                ups_name, ups_desc = ups_list[0]
        else:
            ups_name, ups_desc = ups_list[0]

        if str(ups_desc).strip().lower() in {"description unavailable", "unavailable", "n/a", "na"}:
            ups_desc = ""
        return ups_name, ups_desc


def nut_get_vars(ups_name: str) -> Dict[str, str]:
    host, port, timeout, username, password = _nut_connect_params()
    with NutClient(host, port, timeout=timeout) as c:
        c.login_if_needed(username, password)
        return c.list_vars(ups_name)


def nut_list_cmds(ups_name: str) -> List[str]:
    host, port, timeout, username, password = _nut_connect_params()
    with NutClient(host, port, timeout=timeout) as c:
        c.login_if_needed(username, password)
        return c.list_cmds(ups_name)


def nut_run_cmd(ups_name: str, cmd: str) -> str:
    host, port, timeout, username, password = _nut_connect_params()
    with NutClient(host, port, timeout=timeout) as c:
        c.login_if_needed(username, password)
        return c.instcmd(ups_name, cmd)


def should_send_resend(last_sent_iso: Optional[str], resend_minutes: int) -> bool:
    if resend_minutes <= 0:
        return False
    last = _iso_to_dt(last_sent_iso)
    if not last:
        return True
    return (_now_local() - last) >= _dt.timedelta(minutes=resend_minutes)


def main() -> int:
    parser = argparse.ArgumentParser(description="USVWatch - UPS/USV status mail notifier via NUT.")
    parser.add_argument("--env", dest="env_file", default="", help="Path to env file (default: ./usvwatch.env next to script)")
    parser.add_argument("--print-status", action="store_true", help="Print current UPS vars as JSON and exit")
    parser.add_argument("--test-mail", action="store_true", help="Send a test mail and exit")
    parser.add_argument("--list-commands", action="store_true", help="List available NUT instant commands and exit")
    parser.add_argument("--run-cmd", metavar="CMD", default="", help="Run a NUT instant command (INSTCMD)")
    parser.add_argument("--run-cmd-mail", action="store_true", help="Send a mail report after running --run-cmd")
    args = parser.parse_args()

    base_dir = Path(__file__).resolve().parent
    env_path = Path(args.env_file).expanduser().resolve() if args.env_file else (base_dir / "usvwatch.env")
    load_env_file(env_path)

    lang = pick_language()
    t = I18N[lang]

    include_status_legend = env_bool("INCLUDE_STATUS_LEGEND", True)
    add_human_status_field = env_bool("ADD_HUMAN_STATUS_FIELD", True)
    include_all_vars = env_bool("INCLUDE_ALL_VARS", True)
    all_vars_include_regex = env_str("ALL_VARS_INCLUDE_REGEX", "").strip()
    all_vars_exclude_regex = env_str("ALL_VARS_EXCLUDE_REGEX", "").strip()

    host_label = env_str("HOST_LABEL", socket.gethostname()).strip() or socket.gethostname()
    now = _now_local()

    # Select UPS first (needed for status/commands)
    try:
        ups_name, ups_desc = nut_select_ups()
    except Exception as e:
        if args.list_commands or args.run_cmd or args.print_status:
            print(json.dumps({"error": str(e)}, indent=2, ensure_ascii=False))
            return 1
        ups_name, ups_desc = "", ""

    # --- List commands (no SMTP needed)
    if args.list_commands:
        cmds = nut_list_cmds(ups_name)
        out = {
            "ups": ups_name,
            "desc": ups_desc,
            "title": t["cmd_list_title"],
            "commands": cmds,
        }
        print(json.dumps(out, indent=2, ensure_ascii=False))
        return 0

    # --- Run instant command (no SMTP needed unless --run-cmd-mail)
    if args.run_cmd:
        try:
            result = nut_run_cmd(ups_name, args.run_cmd)
            payload = {"ups": ups_name, "cmd": args.run_cmd, "result": result}
            print(json.dumps(payload, indent=2, ensure_ascii=False))
        except Exception as e:
            payload = {"ups": ups_name, "cmd": args.run_cmd, "error": str(e)}
            print(json.dumps(payload, indent=2, ensure_ascii=False))
            return 1

        if not args.run_cmd_mail:
            return 0
        # otherwise: fall through and send mail report

    # --- Print status (no SMTP needed)
    if args.print_status:
        vars_ = nut_get_vars(ups_name)
        print(json.dumps({"ups": ups_name, "desc": ups_desc, "vars": vars_}, indent=2, ensure_ascii=False))
        return 0

    # ----------------
    # SMTP config (only from here on)
    # ----------------
    smtp_host = env_str("SMTP_HOST", "").strip()
    smtp_port = env_int("SMTP_PORT", 587)
    smtp_user = env_str("SMTP_USER", "").strip()
    smtp_pass = env_str("SMTP_PASS", "").strip()
    smtp_from = env_str("MAIL_FROM", "").strip()
    to_list = [x.strip() for x in env_str("MAIL_TO", "").split(",") if x.strip()]
    cc_list = [x.strip() for x in env_str("MAIL_CC", "").split(",") if x.strip()]
    bcc_list = [x.strip() for x in env_str("MAIL_BCC", "").split(",") if x.strip()]
    smtp_tls = env_str("SMTP_TLS", "starttls").strip().lower()
    smtp_timeout = env_int("SMTP_TIMEOUT", 15)
    tls_verify = env_bool("SMTP_TLS_VERIFY", True)

    if not smtp_host or not smtp_from or not to_list:
        print("ERROR: Mail config incomplete. Set SMTP_HOST, MAIL_FROM, MAIL_TO.", file=sys.stderr)
        return 2

    # Behaviour toggles
    alert_on_battery = env_bool("ALERT_ON_BATTERY", True)
    alert_back_online = env_bool("ALERT_BACK_ONLINE", True)
    alert_low_battery = env_bool("ALERT_LOW_BATTERY", True)
    alert_charge_low = env_bool("ALERT_CHARGE_LOW", True)
    alert_runtime_low = env_bool("ALERT_RUNTIME_LOW", True)
    alert_unreachable = env_bool("ALERT_UNREACHABLE", True)
    alert_recovered = env_bool("ALERT_RECOVERED", True)
    enable_daily_report = env_bool("ENABLE_DAILY_REPORT", False)

    charge_threshold = env_int("CHARGE_THRESHOLD_PERCENT", 20)
    runtime_threshold = env_int("RUNTIME_THRESHOLD_MIN", 10)
    resend_threshold_min = env_int("THRESHOLD_RESEND_MIN", 60)
    unreachable_resend_min = env_int("UNREACHABLE_RESEND_MIN", 120)

    daily_time = env_str("DAILY_REPORT_TIME", "09:00").strip()
    m = re.fullmatch(r"(\d{1,2}):(\d{2})", daily_time)
    daily_hour = int(m.group(1)) if m else 9
    daily_minute = int(m.group(2)) if m else 0

    debug = env_bool("DEBUG", False)

    # State file
    state_dir = Path(env_str("STATE_DIR", str(base_dir))).expanduser()
    state_file = state_dir / "usvwatch_state.json"
    state = load_state(state_file)

    # Query vars (reachable check)
    reachable = True
    vars_: Dict[str, str] = {}
    nut_error = ""
    try:
        if not ups_name:
            ups_name, ups_desc = nut_select_ups()
        vars_ = nut_get_vars(ups_name)
    except Exception as e:
        reachable = False
        nut_error = str(e)

    def do_send(subject: str, event_label: str, desc_override: str = "", extra_rows: Optional[List[Tuple[str, str]]] = None) -> None:
        html = build_html(
            lang=lang,
            event_label=event_label,
            now=now,
            host=host_label,
            ups_name=ups_name or "-",
            ups_desc=(desc_override or ups_desc) if reachable else (desc_override or ""),
            vars_=vars_ if reachable else {"ups.status": "UNREACHABLE", "error": nut_error},
            include_all_vars=(include_all_vars and reachable),
            include_status_legend=include_status_legend,
            add_human_status_field=add_human_status_field,
            extra_rows=extra_rows,
            all_vars_include_regex=all_vars_include_regex,
            all_vars_exclude_regex=all_vars_exclude_regex,
        )
        send_mail(
            smtp_host=smtp_host,
            smtp_port=smtp_port,
            smtp_user=smtp_user,
            smtp_pass=smtp_pass,
            smtp_from=smtp_from,
            smtp_to=to_list,
            smtp_cc=cc_list,
            smtp_bcc=bcc_list,
            smtp_tls=smtp_tls,
            smtp_timeout=smtp_timeout,
            tls_verify=tls_verify,
            subject=subject,
            html_body=html,
        )

    # If we came from --run-cmd --run-cmd-mail: send report now
    if args.run_cmd and args.run_cmd_mail:
        extra = [
            (t["cmd_run_label"], args.run_cmd),
            (t["cmd_run_result"], "OK"),
        ]
        if not reachable:
            do_send(_truncate_subject(t["selftest_subject"]), t["event_selftest"], t["unreachable_hint"], extra_rows=extra)
            print("WARN: UPS vars not readable after command (unreachable).", file=sys.stderr)
            return 0
        do_send(_truncate_subject(t["selftest_subject"]), t["event_selftest"], extra_rows=extra)
        return 0

    # Test mail
    if args.test_mail:
        if not reachable:
            try:
                do_send(_truncate_subject(t["test_subject"]), t["event_test"], f"{t['unreachable_hint']} ({nut_error})")
                print("OK: test mail sent (NUT unreachable).")
                return 0
            except Exception as e:
                print(f"ERROR: test mail failed: {e}", file=sys.stderr)
                return 1
        try:
            do_send(_truncate_subject(t["test_subject"]), t["event_test"])
            print("OK: test mail sent.")
            return 0
        except Exception as e:
            print(f"ERROR: test mail failed: {e}", file=sys.stderr)
            return 1

    # Unreachable handling
    last_reachable = bool(state.get("last_reachable", True))
    if not reachable:
        state["last_reachable"] = False
        state["last_unreachable_error"] = nut_error
        if alert_unreachable and (last_reachable or should_send_resend(state.get("last_unreachable_sent"), unreachable_resend_min)):
            try:
                do_send(_truncate_subject(t["unreachable_subject"]), t["event_unreachable"], t["unreachable_hint"])
                state["last_unreachable_sent"] = _dt_to_iso(now)
            except Exception as e:
                print(f"WARN: Mail send failed (unreachable): {e}", file=sys.stderr)
        save_state(state_file, state)
        return 1

    # Recovered mail
    if (not last_reachable) and alert_recovered:
        try:
            do_send(_truncate_subject(t["recovered_subject"]), t["event_recovered"])
        except Exception as e:
            print(f"WARN: Mail send failed (recovered): {e}", file=sys.stderr)
        state["last_unreachable_sent"] = None
    state["last_reachable"] = True

    ups_status = vars_.get("ups.status", "")
    flags = set((ups_status or "").split())

    prev_ob = bool(state.get("prev_ob", False))
    curr_ob = "OB" in flags

    prev_lb = bool(state.get("prev_lb", False))
    curr_lb = "LB" in flags

    if alert_on_battery and curr_ob and not prev_ob:
        try:
            do_send(_truncate_subject(t["on_battery_subject"]), t["event_on_battery"])
            state["last_on_battery_sent"] = _dt_to_iso(now)
        except Exception as e:
            print(f"WARN: Mail send failed (on battery): {e}", file=sys.stderr)

    if alert_back_online and prev_ob and not curr_ob:
        try:
            do_send(_truncate_subject(t["back_online_subject"]), t["event_back_online"])
            state["last_back_online_sent"] = _dt_to_iso(now)
        except Exception as e:
            print(f"WARN: Mail send failed (back online): {e}", file=sys.stderr)

    if alert_low_battery and curr_lb and not prev_lb:
        try:
            do_send(_truncate_subject(t["low_batt_subject"]), t["event_low_battery"])
            state["last_low_battery_sent"] = _dt_to_iso(now)
        except Exception as e:
            print(f"WARN: Mail send failed (low battery): {e}", file=sys.stderr)

    state["prev_ob"] = curr_ob
    state["prev_lb"] = curr_lb
    state["last_status_raw"] = ups_status

    charge = _safe_float(vars_.get("battery.charge"))
    runtime_sec = _safe_int(vars_.get("battery.runtime"))
    runtime_min = int(runtime_sec / 60) if runtime_sec is not None else None

    if alert_charge_low and (charge is not None) and (charge_threshold > 0) and (charge <= charge_threshold):
        if should_send_resend(state.get("last_charge_alert_sent"), resend_threshold_min):
            try:
                do_send(_truncate_subject(t["charge_low_subject"]), t["event_charge_low"])
                state["last_charge_alert_sent"] = _dt_to_iso(now)
            except Exception as e:
                print(f"WARN: Mail send failed (charge low): {e}", file=sys.stderr)

    if alert_runtime_low and (runtime_min is not None) and (runtime_threshold > 0) and (runtime_min <= runtime_threshold):
        if should_send_resend(state.get("last_runtime_alert_sent"), resend_threshold_min):
            try:
                do_send(_truncate_subject(t["runtime_low_subject"]), t["event_runtime_low"])
                state["last_runtime_alert_sent"] = _dt_to_iso(now)
            except Exception as e:
                print(f"WARN: Mail send failed (runtime low): {e}", file=sys.stderr)

    if enable_daily_report:
        last_date = state.get("daily_last_date")
        today = now.date().isoformat()
        after_time = now.time() >= _dt.time(hour=daily_hour, minute=daily_minute)
        if after_time and last_date != today:
            try:
                do_send(_truncate_subject(t["daily_subject"]), t["event_daily"])
                state["daily_last_date"] = today
            except Exception as e:
                print(f"WARN: Mail send failed (daily report): {e}", file=sys.stderr)

    if debug:
        human, _ = explain_ups_status(ups_status, lang)
        print(f"DEBUG: lang='{lang}' ups.status='{ups_status}' human='{human}' charge={charge} runtime_min={runtime_min}")

    save_state(state_file, state)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
